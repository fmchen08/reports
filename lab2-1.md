# Linux多进程编程
## 编写一个打开文件的程序（使用open()系统调用），然后调用fork()创建一个新进程。设计实验回答以下问题：
- 子进程和父进程都可以访问open()返回的文件描述符吗？
- 当它们并发写入文件时（使用write()系统调用），会发生什么？
- 如何保证子进程始终先写？你能否不在父进程调用wait()而做到这一点呢？
- 在父进程中使用wait()，等待子进程完成。wait()返回什么？如果你在子进程中使用wait()会发生什么？

提示：

（1）可能用到的头文件


    #include <stdio.h>
    #include <stdlib.h>
    #include <unistd.h>
    #include <sys/wait.h>
    #include <fcntl.h>
    #include <string.h>

（2）open()系统调用的例子:

    int fid;
    fid = open(“./out”, O_CREAT | O_WRONLY | O_TRUNC, S_IRWXU);

（3）使用man 2查询系统调用的用法，如 

    man 2 write
    man 2 open

---
## 文件描述符
### 简介
文件描述符在形式上是一个非负整数。实际上，**它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表**。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。

习惯上，标准输入(standard input)的文件描述符是 0，标准输出(standard output)是 1，标准错误(standard error)是 2。POSIX 定义了 STDIN_FILENO、STDOUT_FILENO 和 STDERR_FILENO 来代替 0、1、2。这三个符号常量的定义位于头文件 unistd.h。

文件描述符的有效范围是 0 到 OPEN_MAX。一般来说，每个进程最多可以打开 64 个文件(0 - 63)。对于 FreeBSD 5.2.1、Mac OS X 10.3 和 Solaris 9 来说，每个进程最多可以打开文件的多少取决于系统内存的大小，int 的大小，以及系统管理员设定的限制。Linux 2.4.22 强制规定最多不能超过 1,048,576。

文件描述符是由无符号整数表示的句柄，进程使用它来标识打开的文件。文件描述符与包括相关信息(如文件的打开模式、文件的位置类型、文件的初始类型等)的文件对象相关联，这些信息被称作文件的上下文。

### 如何创建文件描述符
- 通过open或create获取。
- 通过从父进程继承。

后一种方法允许子进程同样能够访问由父进程使用的文件。文件描述符对于每个进程一般是唯一的。当用fork创建某个子进程时，该子进程会获得其父进程所有文件描述符的副本，这些文件描述符在执行fork时打开。对于每个进程，操作系统内核在u_block结构中维护文件描述符表，所有的文件描述符都在该表中建立索引。
